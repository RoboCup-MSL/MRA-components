#!/usr/bin/env python3

"""
Print contents of a tick .bin file.
"""

EXAMPLE_TEXT = None

# python modules
import sys
import os
os.environ["PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION"] = "python"
import argparse
import json
import copy
import struct
import importlib
from google.protobuf.message import Message
from google.protobuf.descriptor import FieldDescriptor
from google.protobuf.json_format import MessageToJson

# get common datatypes generated by protobuf, take cmake build/ folder
# it works for now, but TODO: make this nicer ...
try:
    sys.path.append(os.path.join(os.path.dirname(__file__), 'build'))
    import datatypes.Meta_pb2
    # the type of the header is always the same
    # based on the content of the header, dynamic imports can be done
except ImportError:
    raise ImportError('failed to import datatypes.Meta_pb2, perhaps cmake build was not done?')
    # or try bazel build location?



# constants
FILE_ELEMENTS = (
    'meta',
    'input',
    'params',
    'state_before',
    'output',
    'local',
    'state_after',
    )
EXPECTED_FILE_ELEMENT_COUNT = len(FILE_ELEMENTS)
# these are all protobuf objects


def parse_args(args: list) -> argparse.Namespace:
    """
    Use argparse to parse command line arguments.
    """
    descriptionTxt = __doc__
    exampleTxt = ''
    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter):
        pass
    parser = argparse.ArgumentParser(description=descriptionTxt, epilog=exampleTxt, formatter_class=CustomFormatter)
    parser.add_argument('-J', '--no-json', dest='json', help='do not print as json string, instead use protobuf string formatting, multiline', action='store_false')
    parser.add_argument('-i', '--indent-json', help='json indentation to use', default=None)
    parser.add_argument('-b', '--binary', help='do not strip binary data', action='store_true')
    parser.add_argument('-s', '--state', help='also print state, both before and after, instead of hiding', action='store_true')
    parser.add_argument('datafile', help='data file (.bin) to load')
    return parser.parse_args(args)



class Data():

    def __init__(self, filename):
        self.load(filename)

    def load(self, filename):
        # load all binary data, uninterpreted
        self.raw_load(filename)
        # parse meta header to find out the type(s) to use when interpreting raw data
        self.parse_meta_header()
        # assign raw_data to types of the current component
        self.parse_component_data()

    def raw_load(self, filename):
        self.raw_data = {}
        loaded_elem_count = 0
        with open(filename, 'rb') as f:
            for key in FILE_ELEMENTS:
                n = struct.unpack('i', f.read(4))[0]
                self.raw_data[key] = f.read(n)
                loaded_elem_count += 1
        if loaded_elem_count != EXPECTED_FILE_ELEMENT_COUNT:
            print('WARNING: file has {:d} elements, but {:d} were expected'.format(loaded_elem_count, EXPECTED_FILE_ELEMENT_COUNT))

    def parse_meta_header(self):
        self.meta = datatypes.Meta_pb2.Meta()
        self.meta.MergeFromString(self.raw_data['meta'])

    def parse_component_data(self):
        for elem in FILE_ELEMENTS[1:]: # skip first element (meta)
            key = elem.split('_')[0]
            Key = key.capitalize() # example Input
            # dynamic import of component interface
            key_module = '{:s}_pb2'.format(Key) # example Input_pb2
            module_name = 'components.{:s}.interface.{:s}'.format(self.meta.subfolder.replace('/', '.'), key_module, Key)
            try:
                module = importlib.import_module(module_name)
            except:
                continue
            # construct message and merge from raw data
            msg = getattr(module, Key)()
            msg.MergeFromString(self.raw_data[elem])
            # store
            setattr(self, elem, msg)



def protobuf_message_reduction(message: Message, options: dict = {}) -> Message:
    """
    Recursively removes / replaces data from a Protobuf message (protobuf v3).
    """
    # options
    if not 'binary_replacement' in options:
        options['binary_replacement'] = b''
    if not 'repeated_clear' in options:
        options['repeated_clear'] = False
    # modify
    for field in message.DESCRIPTOR.fields:
        if field.name in message.DESCRIPTOR.fields_by_name and message.DESCRIPTOR.fields_by_name[field.name].type == FieldDescriptor.TYPE_BYTES:
            if not options.get('binary_replacement') is None:
                setattr(message, field.name, options.get('binary_replacement'))
        elif field.name in message.DESCRIPTOR.fields_by_name and message.DESCRIPTOR.fields_by_name[field.name].label == FieldDescriptor.LABEL_REPEATED:
            if options.get('repeated_clear'):
                getattr(message, field.name).clear()
        elif isinstance(getattr(message, field.name), Message):
            protobuf_message_reduction(getattr(message, field.name), options)
    return message


def main(args: argparse.Namespace) -> None:
    """
    Print the information.
    """
    # load the data
    data = Data(args.datafile)
    # option handling
    options = {'repeated_clear': False, 'binary_replacement': b''}
    if args.binary: # not sure why this would be useful ...
        options['binary_replacement'] = None
    if args.indent_json:
        args.json = True
        # use ints if possible, the json formatter otherwise uses digits as prefix string
        try:
            args.indent_json = int(args.indent_json)
        except:
            pass
    # state before and after
    # TODO: option to calculate state change? difflib?
    if not args.state:
        for s in ('state_before', 'state_after'):
            if hasattr(data, s):
                delattr(data, s)
    # start printing after optionally massaging data
    elements = FILE_ELEMENTS # input, params, state, output etc
    for e in elements:
        if hasattr(data, e):
            # general reduction
            v = protobuf_message_reduction(getattr(data, e), options)
            # print
            print('\n' + e + ':\n')
            if args.json:
                print(MessageToJson(v, indent=args.indent_json))
            else:
                print(v)


if __name__ == '__main__':
    main(parse_args(sys.argv[1:]))


