syntax = "proto3";

package MRA.RobotsportsRoleAssigner;

import "google/protobuf/timestamp.proto";
import "datatypes/Pose.proto";
import "datatypes/Point.proto";
import "datatypes/Ball.proto";
import "datatypes/Obstacle.proto";

//  - current dynamic role. 
// part of robot_strategy/interface/Output.proto
enum DynamicRole {
    UNDEFINED = 0;
    GOALKEEPER = 1;
    ATTACKER_MAIN = 2;
    ATTACKER_ASSIST = 3;
    ATTACKER_GENERIC = 4;
    DEFENDER_MAIN = 5;
    DEFENDER_GENERIC = 6;
    DISABLED_OUT = 7;
    DISABLED_IN = 8;
};


message Player
{
    // typically on the floor, so z,rx,ry unused
    int32 id = 1; // T-shirt number
    bool active = 2; // participating in the game (robot may be inactive when figuring out where it is)
    bool human = 3;
    MRA.Datatypes.Pose position = 4;
    MRA.Datatypes.Pose velocity = 5;
    bool hasball = 6;
    bool passed_ball = 7;
    bool is_keeper = 8;
    double  time_in_own_penalty_area = 9;
    double time_in_opponent_penalty_area = 10;
    // double energy, competence? Reasoning should take it account when choosing player to pass to
    // radius?
    DynamicRole dynamic_role = 11;
    int32 trackingId = 12; // id of object tracking
}

message PickUpPosition
{
    MRA.Datatypes.Pose position = 1; // pickup position
    google.protobuf.Timestamp timestamp = 2; // timestamp of pickup
}


// part of  input data
message PassData {
   bool  valid = 1; // 1: if data is valid; 0 otherwise
   bool   kicked = 2; // 1: if pass/shot has been made; 0: otherwise
   int32   target_id =3;  // destination of kick, where 0 is goal
   double velocity = 4; // [m/s]
   double angle = 5 ; // upwards angle
   MRA.Datatypes.Point  origin_pos = 6; // field coordinates of origin
   MRA.Datatypes.Point  target_pos = 7; // field coordinates of target
   google.protobuf.Timestamp timestamp = 8; // timestamp of update
   google.protobuf.Timestamp eta = 9; // estimated time of arrival at target
};

message Opponent {
    MRA.Datatypes.Pose position = 1;
    MRA.Datatypes.Pose velocity = 2;
    int32 trackingId = 3;
}

// class with inp

message Input
{
    enum GameState
    {
        NONE = 0;
        NORMAL = 1;
        NORMAL_ATTACK = 2;
        NORMAL_DEFEND = 3;
        PARKING = 4;
        BEGIN_POSITION = 5;
        KICKOFF = 6;
        KICKOFF_AGAINST = 7;
        FREEKICK = 8;
        FREEKICK_AGAINST = 9;
        GOALKICK = 10;
        GOALKICK_AGAINST = 11;
        THROWIN = 12;
        THROWIN_AGAINST = 13;
        CORNER = 14;
        CORNER_AGAINST = 15;
        PENALTY = 16;
        PENALTY_AGAINST = 17;
        PENALTY_SHOOTOUT = 18;
        PENALTY_SHOOTOUT_AGAINST = 19;
        DROPPED_BALL = 20;
        YELLOW_CARD_AGAINST = 21;
        RED_CARD_AGAINST = 22;
        GOAL = 23;
        GOAL_AGAINST = 24;
    }

    GameState gamestate = 2;
    repeated MRA.Datatypes.Ball ball = 3; // allow maximum one ball in the field/test; if there are more, then WorldModel should provide closest one, can be none.

    repeated DynamicRole formation = 11;

    repeated Player team = 4;
    repeated Opponent opponents = 5;
    repeated PickUpPosition pickup = 6; // pickup position
    bool passIsRequired = 7;
    repeated MRA.Datatypes.Pose parking_positions = 8;
    PickUpPosition ball_pickup_position = 9;
    PassData pass_data = 10;
};
    
// TODO add game info to allow decision based on score and time remaining etc.
// Usage of MRA vector class
// Opponents is same as Player, but has different attributes
// NoOpponentObstacles

