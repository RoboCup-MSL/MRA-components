syntax = "proto3";

package MRA.RobotsportsRoleAssigner;

import "google/protobuf/timestamp.proto";
import "datatypes/Pose.proto";
import "datatypes/Point.proto";
import "datatypes/Ball.proto";
import "datatypes/Obstacle.proto";
import "components/robotsports/role_assigner/interface/Output.proto";



message Player
{
    // typically on the floor, so z,rx,ry unused
    int32 id = 1; // T-shirt number
    bool active = 2; // participating in the game (robot may be inactive when figuring out where it is)
    bool human = 3;
    MRA.Datatypes.Pose position = 4;
    MRA.Datatypes.Pose velocity = 5;
    bool hasball = 6;
    bool passed_ball = 7;
    bool is_keeper = 8;
    double  time_in_own_penalty_area = 9;
    double time_in_opponent_penalty_area = 10;
    // double energy, competence? Reasoning should take it account when choosing player to pass to
    // radius?
    DynamicRole dynamic_role = 11;
    int32 trackingId = 12; // id of object tracking
}

message PickUpPosition
{
    MRA.Datatypes.Pose position = 1; // pickup position
    google.protobuf.Timestamp timestamp = 2; // timestamp of pickup
}


// part of  input data
message PassData {
   bool  valid = 1; // 1: if data is valid; 0 otherwise
   bool   kicked = 2; // 1: if pass/shot has been made; 0: otherwise
   int32   target_id =3;  // destination of kick, where 0 is goal
   double velocity = 4; // [m/s]
   double angle = 5 ; // upwards angle
   MRA.Datatypes.Point  origin_pos = 6; // field coordinates of origin
   MRA.Datatypes.Point  target_pos = 7; // field coordinates of target
   google.protobuf.Timestamp timestamp = 8; // timestamp of update
   google.protobuf.Timestamp eta = 9; // estimated time of arrival at target
};

message Opponent {
    MRA.Datatypes.Pose position = 1;
    MRA.Datatypes.Pose velocity = 2;
    int32 trackingId = 3;
}

// class with inp

message Input
{
    enum GameState
    {
        NONE = 0;
        NORMAL = 1;
        NORMAL_ATTACK = 2;
        NORMAL_DEFEND = 3;
        PARKING = 4;
        BEGIN_POSITION = 5;
        KICKOFF = 6;
        KICKOFF_AGAINST = 7;
        FREEKICK = 8;
        FREEKICK_AGAINST = 9;
        GOALKICK = 10;
        GOALKICK_AGAINST = 11;
        THROWIN = 12;
        THROWIN_AGAINST = 13;
        CORNER = 14;
        CORNER_AGAINST = 15;
        PENALTY = 16;
        PENALTY_AGAINST = 17;
        PENALTY_SHOOTOUT = 18;
        PENALTY_SHOOTOUT_AGAINST = 19;
        DROPPED_BALL = 20;
        YELLOW_CARD_AGAINST = 21;
        RED_CARD_AGAINST = 22;
        GOAL = 23;
        GOAL_AGAINST = 24;
    }

    GameState gamestate = 2;
    repeated MRA.Datatypes.Ball ball = 3; // allow maximum one ball in the field/test; if there are more, then WorldModel should provide closest one, can be none.

    repeated DynamicRole formation = 11; // ordered list of dynamic roles to be assigned.

    repeated Player team = 4;   // players in the team (own player is first in the list)
    repeated Opponent opponents = 5; // opponents participating in the games
    repeated Opponent no_opponent_obstacles = 12; // detected obstacles which are not a team-mate or opponent
    repeated PickUpPosition pickup = 6; // pickup position
    bool passIsRequired = 7;  // is pass required to make valid goal
    repeated MRA.Datatypes.Pose parking_positions = 8; // location of the parking positions (later: onlyin case of no technical area)
    PickUpPosition ball_pickup_position = 9;  // where was the ball picked up; avoid to transport the ball over a too large distance with ball (MSL-rule) (if present)
    PassData pass_data = 10; // information over a pass (if present)
};
    
// TODO add game info to allow decision based on score and time remaining etc.
// Usage of MRA vector class
// Opponents is same as Player, but has different attributes

