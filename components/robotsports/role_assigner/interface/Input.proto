syntax = "proto3";

package MRA.RobotsportsRoleAssigner;

import "google/protobuf/timestamp.proto";
import "datatypes/Pose.proto";
import "datatypes/Ball.proto";
import "datatypes/Obstacle.proto";

//  - current dynamic role. 
// part of robot_strategy/interface/Output.proto
enum DynamicRole {
    NONE = 0;
    GOALKEEPER = 1;
    ATTACKSUPPORTER = 2;
    DEFENDER = 3;
    INTERCEPTOR = 4;
    SWEEPER = 5;
    SETPLAY_RECEIVER = 6;
    SETPLAY_KICKER = 7;
    BALLPLAYER = 8;
    SEARCH_FOR_BALL = 9;
    BEGIN_POSITION = 10;
    PARKING = 11;
    PENALTY_KICKER = 12;
};


message Player
{
    // typically on the floor, so z,rx,ry unused
    int32 id = 1; // T-shirt number
    bool active = 2; // participating in the game (robot may be inactive when figuring out where it is)
    bool human = 3;
    MRA.Datatypes.Pose position = 4;
    MRA.Datatypes.Pose velocity = 5;
    bool hasball = 6;
    bool passed_ball = 7;
    bool is_keeper = 8;
    double  time_in_own_penalty_area = 9;
    double time_in_opponent_penalty_area = 10;
    // double energy, competence? Reasoning should take it account when choosing player to pass to
    // radius?
    DynamicRole dynamic_role = 11;
}

message PickUpPosition
{
    MRA.Datatypes.Pose position = 1; // pickup position
    google.protobuf.Timestamp timestamp = 2; // timestamp of pickup
}


// part of  input data
message PassData {
//    bool    valid; // 1: if data is valid; 0 otherwise
//    bool   kicked; // 1: if pass/shot has been made; 0: otherwise
    //long   target_id; // destination of kick, where 0 is goal
    //double velocity; // [m/s]
    //double angle; // upwards angle
    //MRA::Geometry::Point  origin_pos; // field coordinates of origin
    //MRA::Geometry::Point  target_pos; // field coordinates of target
    //double ts; // timestamp of update
    //double eta; // estimated time of arrival at target
};


// class with inp

message Input
{
	enum GameState
	{
		NONE = 0;
		NORMAL = 1;
		NORMAL_ATTACK = 2;
		NORMAL_DEFEND = 3;
		PARKING = 4;
		BEGIN_POSITION = 5;
		KICKOFF = 6;
		KICKOFF_AGAINST = 7;
		FREEKICK = 8;
		FREEKICK_AGAINST = 9;
		GOALKICK = 10;
		GOALKICK_AGAINST = 11;
		THROWIN = 12;
		THROWIN_AGAINST = 13;
		CORNER = 14;
		CORNER_AGAINST = 15;
		PENALTY = 16;
		PENALTY_AGAINST = 17;
		PENALTY_SHOOTOUT = 18;
		PENALTY_SHOOTOUT_AGAINST = 19;
		DROPPED_BALL = 20;
		YELLOW_CARD_AGAINST = 21;
		RED_CARD_AGAINST = 22;
		GOAL = 23;
		GOAL_AGAINST = 24;
	}

    Player robot = 1; // self
    GameState gamestate = 2;
    repeated MRA.Datatypes.Ball ball = 3; // allow maximum one ball in the field/test; if there are more, then WorldModel should provide closest one, can be none.
    repeated Player teammates = 4;
    repeated Player opponents = 5;
    repeated PickUpPosition pickup = 6; // pickup position
    bool passIsRequired = 7;
    repeated PassData pass_data = 8;
//    std::vector<dynamic_role_e> teamFormation;
//    std::vector<MRA::Geometry::Point> parking_positions;  // config
//    MRA::FieldConfig fieldConfig;
    
    
}


