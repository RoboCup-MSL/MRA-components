syntax = "proto3";

package MRA.FalconsMotionPlanning;

import "datatypes/Point.proto";
import "datatypes/PosVel.proto";
import "datatypes/WorldState.proto";
import "datatypes/ActionType.proto";
import "components/falcons/getball/interface/Input.proto";
import "components/falcons/action_aimed_kick/interface/Input.proto";

message ActionStopInputs
{
    bool ballHandlersEnabled = 1;
}

message ActionMoveInputs
{
    MRA.Datatypes.PosVel target = 1;
    int32 motionType = 2; // optional
    bool ballHandlersEnabled = 3;
}

message ActionKickInputs
{
    float power = 1;
    float height = 2;
}

message ActionShootInputs
{
    MRA.Datatypes.PosVel target = 1; // typically only using pos.x, pos.y and pos.z
}

message ActionLobShotInputs
{
    MRA.Datatypes.PosVel target = 1; // typically only using pos.x, pos.y and pos.z
}

message ActionShieldInputs
{
}

message ActionKeeperInputs
{
}

message ActionInterceptInputs
{
    float radius = 2; // optional
}

message ActionInputs
{
    MRA.Datatypes.ActionType type = 1;
    oneof inputs
    {
        ActionStopInputs stop = 2;
        ActionMoveInputs move = 3;
        ActionKickInputs kick = 4;
        MRA.FalconsActionAimedKick.Input pass = 5;
        ActionShootInputs shoot = 6;
        ActionLobShotInputs lob = 7;
        MRA.FalconsGetball.Input getball = 8;
        ActionShieldInputs shield = 9;
        ActionKeeperInputs keeper = 10;
        ActionInterceptInputs intercept = 11;
    }
}

message ForbiddenArea
{
    repeated MRA.Datatypes.Point points = 1;
}

message Input
{
    ActionInputs action = 1;
    MRA.Datatypes.WorldState worldState = 2;
    repeated ForbiddenArea forbiddenAreas = 3;
}

